
ISR_inSAMD20.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000750  00000000  00000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000000  20000000  20000000  00010750  2**0
                  CONTENTS
  2 .bss          00000050  20000000  20000000  00020000  2**2
                  ALLOC
  3 .stack        00002000  20000050  20000050  00020000  2**0
                  ALLOC
  4 .ARM.attributes 00000028  00000000  00000000  00010750  2**0
                  CONTENTS, READONLY
  5 .comment      00000059  00000000  00000000  00010778  2**0
                  CONTENTS, READONLY
  6 .debug_info   0000afa4  00000000  00000000  000107d1  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000199f  00000000  00000000  0001b775  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    0000159d  00000000  00000000  0001d114  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 000002b8  00000000  00000000  0001e6b1  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000218  00000000  00000000  0001e969  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  0000eefa  00000000  00000000  0001eb81  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   00007697  00000000  00000000  0002da7b  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    0004d863  00000000  00000000  00035112  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  000004fc  00000000  00000000  00082978  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <exception_table>:
   0:	50 20 00 20 15 01 00 00 11 01 00 00 11 01 00 00     P . ............
	...
  2c:	11 01 00 00 00 00 00 00 00 00 00 00 11 01 00 00     ................
  3c:	11 01 00 00 11 01 00 00 11 01 00 00 11 01 00 00     ................
  4c:	d1 05 00 00 11 01 00 00 11 01 00 00 11 01 00 00     ................
  5c:	11 01 00 00 11 01 00 00 11 01 00 00 11 01 00 00     ................
  6c:	11 01 00 00 11 01 00 00 11 01 00 00 11 01 00 00     ................
  7c:	11 01 00 00 11 01 00 00 11 01 00 00 11 01 00 00     ................
  8c:	11 01 00 00 11 01 00 00 11 01 00 00 11 01 00 00     ................
  9c:	11 01 00 00 11 01 00 00                             ........

000000a4 <__do_global_dtors_aux>:
  a4:	b510      	push	{r4, lr}
  a6:	4c06      	ldr	r4, [pc, #24]	; (c0 <__do_global_dtors_aux+0x1c>)
  a8:	7823      	ldrb	r3, [r4, #0]
  aa:	2b00      	cmp	r3, #0
  ac:	d107      	bne.n	be <__do_global_dtors_aux+0x1a>
  ae:	4b05      	ldr	r3, [pc, #20]	; (c4 <__do_global_dtors_aux+0x20>)
  b0:	2b00      	cmp	r3, #0
  b2:	d002      	beq.n	ba <__do_global_dtors_aux+0x16>
  b4:	4804      	ldr	r0, [pc, #16]	; (c8 <__do_global_dtors_aux+0x24>)
  b6:	e000      	b.n	ba <__do_global_dtors_aux+0x16>
  b8:	bf00      	nop
  ba:	2301      	movs	r3, #1
  bc:	7023      	strb	r3, [r4, #0]
  be:	bd10      	pop	{r4, pc}
  c0:	20000000 	.word	0x20000000
  c4:	00000000 	.word	0x00000000
  c8:	00000750 	.word	0x00000750

000000cc <frame_dummy>:
  cc:	4b08      	ldr	r3, [pc, #32]	; (f0 <frame_dummy+0x24>)
  ce:	b510      	push	{r4, lr}
  d0:	2b00      	cmp	r3, #0
  d2:	d003      	beq.n	dc <frame_dummy+0x10>
  d4:	4907      	ldr	r1, [pc, #28]	; (f4 <frame_dummy+0x28>)
  d6:	4808      	ldr	r0, [pc, #32]	; (f8 <frame_dummy+0x2c>)
  d8:	e000      	b.n	dc <frame_dummy+0x10>
  da:	bf00      	nop
  dc:	4807      	ldr	r0, [pc, #28]	; (fc <frame_dummy+0x30>)
  de:	6803      	ldr	r3, [r0, #0]
  e0:	2b00      	cmp	r3, #0
  e2:	d100      	bne.n	e6 <frame_dummy+0x1a>
  e4:	bd10      	pop	{r4, pc}
  e6:	4b06      	ldr	r3, [pc, #24]	; (100 <frame_dummy+0x34>)
  e8:	2b00      	cmp	r3, #0
  ea:	d0fb      	beq.n	e4 <frame_dummy+0x18>
  ec:	4798      	blx	r3
  ee:	e7f9      	b.n	e4 <frame_dummy+0x18>
  f0:	00000000 	.word	0x00000000
  f4:	20000004 	.word	0x20000004
  f8:	00000750 	.word	0x00000750
  fc:	00000750 	.word	0x00000750
 100:	00000000 	.word	0x00000000

00000104 <atmel_start_init>:

/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
 104:	b510      	push	{r4, lr}
	system_init();
 106:	4b01      	ldr	r3, [pc, #4]	; (10c <atmel_start_init+0x8>)
 108:	4798      	blx	r3
}
 10a:	bd10      	pop	{r4, pc}
 10c:	000001c9 	.word	0x000001c9

00000110 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
 110:	e7fe      	b.n	110 <Dummy_Handler>
	...

00000114 <Reset_Handler>:
{
 114:	b510      	push	{r4, lr}
        if (pSrc != pDest) {
 116:	4a12      	ldr	r2, [pc, #72]	; (160 <Reset_Handler+0x4c>)
 118:	4b12      	ldr	r3, [pc, #72]	; (164 <Reset_Handler+0x50>)
 11a:	429a      	cmp	r2, r3
 11c:	d009      	beq.n	132 <Reset_Handler+0x1e>
 11e:	4b11      	ldr	r3, [pc, #68]	; (164 <Reset_Handler+0x50>)
 120:	4a0f      	ldr	r2, [pc, #60]	; (160 <Reset_Handler+0x4c>)
 122:	e003      	b.n	12c <Reset_Handler+0x18>
                        *pDest++ = *pSrc++;
 124:	6811      	ldr	r1, [r2, #0]
 126:	6019      	str	r1, [r3, #0]
 128:	3304      	adds	r3, #4
 12a:	3204      	adds	r2, #4
                for (; pDest < &_erelocate;) {
 12c:	490e      	ldr	r1, [pc, #56]	; (168 <Reset_Handler+0x54>)
 12e:	428b      	cmp	r3, r1
 130:	d3f8      	bcc.n	124 <Reset_Handler+0x10>
                        *pDest++ = *pSrc++;
 132:	4b0e      	ldr	r3, [pc, #56]	; (16c <Reset_Handler+0x58>)
 134:	e002      	b.n	13c <Reset_Handler+0x28>
                *pDest++ = 0;
 136:	2200      	movs	r2, #0
 138:	601a      	str	r2, [r3, #0]
 13a:	3304      	adds	r3, #4
        for (pDest = &_szero; pDest < &_ezero;) {
 13c:	4a0c      	ldr	r2, [pc, #48]	; (170 <Reset_Handler+0x5c>)
 13e:	4293      	cmp	r3, r2
 140:	d3f9      	bcc.n	136 <Reset_Handler+0x22>
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
 142:	4a0c      	ldr	r2, [pc, #48]	; (174 <Reset_Handler+0x60>)
 144:	21ff      	movs	r1, #255	; 0xff
 146:	4b0c      	ldr	r3, [pc, #48]	; (178 <Reset_Handler+0x64>)
 148:	438b      	bics	r3, r1
 14a:	6093      	str	r3, [r2, #8]
        NVMCTRL->CTRLB.bit.MANW = 1;
 14c:	4a0b      	ldr	r2, [pc, #44]	; (17c <Reset_Handler+0x68>)
 14e:	6851      	ldr	r1, [r2, #4]
 150:	2380      	movs	r3, #128	; 0x80
 152:	430b      	orrs	r3, r1
 154:	6053      	str	r3, [r2, #4]
        __libc_init_array();
 156:	4b0a      	ldr	r3, [pc, #40]	; (180 <Reset_Handler+0x6c>)
 158:	4798      	blx	r3
        main();
 15a:	4b0a      	ldr	r3, [pc, #40]	; (184 <Reset_Handler+0x70>)
 15c:	4798      	blx	r3
 15e:	e7fe      	b.n	15e <Reset_Handler+0x4a>
 160:	00000750 	.word	0x00000750
 164:	20000000 	.word	0x20000000
 168:	20000000 	.word	0x20000000
 16c:	20000000 	.word	0x20000000
 170:	20000050 	.word	0x20000050
 174:	e000ed00 	.word	0xe000ed00
 178:	00000000 	.word	0x00000000
 17c:	41004000 	.word	0x41004000
 180:	00000699 	.word	0x00000699
 184:	00000685 	.word	0x00000685

00000188 <TIMER_0_init>:
 * \brief Timer initialization function
 *
 * Enables Timer peripheral, clocks and initializes Timer driver
 */
static void TIMER_0_init(void)
{
 188:	b510      	push	{r4, lr}
			peripheral = (uint32_t)_pm_get_ahb_index(module);
			PM->AHBMASK.reg |= 1 << peripheral;
		}
		break;
	case PM_BUS_APBA:
		PM->APBAMASK.reg |= 1 << peripheral;
 18a:	4a08      	ldr	r2, [pc, #32]	; (1ac <TIMER_0_init+0x24>)
 18c:	6993      	ldr	r3, [r2, #24]
 18e:	2120      	movs	r1, #32
 190:	430b      	orrs	r3, r1
 192:	6193      	str	r3, [r2, #24]
}

static inline void hri_gclk_write_CLKCTRL_reg(const void *const hw, hri_gclk_clkctrl_reg_t data)
{
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->CLKCTRL.reg = data;
 194:	4a06      	ldr	r2, [pc, #24]	; (1b0 <TIMER_0_init+0x28>)
 196:	4b07      	ldr	r3, [pc, #28]	; (1b4 <TIMER_0_init+0x2c>)
 198:	805a      	strh	r2, [r3, #2]
	_pm_enable_bus_clock(PM_BUS_APBA, RTC);
	_gclk_enable_channel(RTC_GCLK_ID, CONF_GCLK_RTC_SRC);
	timer_init(&TIMER_0, RTC, _rtc_get_timer());
 19a:	4b07      	ldr	r3, [pc, #28]	; (1b8 <TIMER_0_init+0x30>)
 19c:	4798      	blx	r3
 19e:	0002      	movs	r2, r0
 1a0:	4906      	ldr	r1, [pc, #24]	; (1bc <TIMER_0_init+0x34>)
 1a2:	4807      	ldr	r0, [pc, #28]	; (1c0 <TIMER_0_init+0x38>)
 1a4:	4b07      	ldr	r3, [pc, #28]	; (1c4 <TIMER_0_init+0x3c>)
 1a6:	4798      	blx	r3
}
 1a8:	bd10      	pop	{r4, pc}
 1aa:	46c0      	nop			; (mov r8, r8)
 1ac:	40000400 	.word	0x40000400
 1b0:	00004002 	.word	0x00004002
 1b4:	40000c00 	.word	0x40000c00
 1b8:	000005cd 	.word	0x000005cd
 1bc:	40001400 	.word	0x40001400
 1c0:	20000034 	.word	0x20000034
 1c4:	000002e1 	.word	0x000002e1

000001c8 <system_init>:

void system_init(void)
{
 1c8:	b510      	push	{r4, lr}
 * Currently the following initialization functions are supported:
 *  - System clock initialization
 */
static inline void init_mcu(void)
{
	_init_chip();
 1ca:	4b0b      	ldr	r3, [pc, #44]	; (1f8 <system_init+0x30>)
 1cc:	4798      	blx	r3
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = ~data;
}

static inline void hri_port_clear_OUT_reg(const void *const hw, uint8_t submodule_index, hri_port_out_reg_t mask)
{
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
 1ce:	23c0      	movs	r3, #192	; 0xc0
 1d0:	05db      	lsls	r3, r3, #23
 1d2:	2280      	movs	r2, #128	; 0x80
 1d4:	01d2      	lsls	r2, r2, #7
 1d6:	615a      	str	r2, [r3, #20]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
 1d8:	609a      	str	r2, [r3, #8]

static inline void hri_port_write_WRCONFIG_reg(const void *const hw, uint8_t submodule_index,
                                               hri_port_wrconfig_reg_t data)
{
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
 1da:	4b08      	ldr	r3, [pc, #32]	; (1fc <system_init+0x34>)
 1dc:	4a08      	ldr	r2, [pc, #32]	; (200 <system_init+0x38>)
 1de:	629a      	str	r2, [r3, #40]	; 0x28
 1e0:	22c0      	movs	r2, #192	; 0xc0
 1e2:	0612      	lsls	r2, r2, #24
 1e4:	629a      	str	r2, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
 1e6:	214e      	movs	r1, #78	; 0x4e
 1e8:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PINCFG_PMUXEN;
 1ea:	2001      	movs	r0, #1
 1ec:	4382      	bics	r2, r0
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
 1ee:	545a      	strb	r2, [r3, r1]
	// Set pin direction to output
	gpio_set_pin_direction(LED_onBoard, GPIO_DIRECTION_OUT);

	gpio_set_pin_function(LED_onBoard, GPIO_PIN_FUNCTION_OFF);

	TIMER_0_init();
 1f0:	4b04      	ldr	r3, [pc, #16]	; (204 <system_init+0x3c>)
 1f2:	4798      	blx	r3
}
 1f4:	bd10      	pop	{r4, pc}
 1f6:	46c0      	nop			; (mov r8, r8)
 1f8:	00000479 	.word	0x00000479
 1fc:	41004400 	.word	0x41004400
 200:	40004000 	.word	0x40004000
 204:	00000189 	.word	0x00000189

00000208 <atomic_enter_critical>:
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 208:	f3ef 8310 	mrs	r3, PRIMASK
/**
 * \brief Disable interrupts, enter critical section
 */
void atomic_enter_critical(hal_atomic_t volatile *atomic)
{
	*atomic = __get_PRIMASK();
 20c:	6003      	str	r3, [r0, #0]
  __ASM volatile ("cpsid i" : : : "memory");
 20e:	b672      	cpsid	i
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
 210:	f3bf 8f5f 	dmb	sy
	__disable_irq();
	__DMB();
}
 214:	4770      	bx	lr

00000216 <atomic_leave_critical>:
 216:	f3bf 8f5f 	dmb	sy
 * \brief Exit atomic section
 */
void atomic_leave_critical(hal_atomic_t volatile *atomic)
{
	__DMB();
	__set_PRIMASK(*atomic);
 21a:	6803      	ldr	r3, [r0, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 21c:	f383 8810 	msr	PRIMASK, r3
}
 220:	4770      	bx	lr
	...

00000224 <timer_add_timer_task>:
 * \param[in] head The pointer to the head of timer task list
 * \param[in] task The pointer to task to add
 * \param[in] time Current timer time
 */
static void timer_add_timer_task(struct list_descriptor *list, struct timer_task *const new_task, const uint32_t time)
{
 224:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 * \return A pointer to the head of the given list or NULL if the list is
 * empty
 */
static inline void *list_get_head(const struct list_descriptor *const list)
{
	return (void *)list->head;
 226:	6806      	ldr	r6, [r0, #0]
	struct timer_task *it, *prev = NULL, *head = (struct timer_task *)list_get_head(list);

	if (!head) {
 228:	2e00      	cmp	r6, #0
 22a:	d002      	beq.n	232 <timer_add_timer_task+0xe>
 22c:	0033      	movs	r3, r6
 22e:	2500      	movs	r5, #0
 230:	e00c      	b.n	24c <timer_add_timer_task+0x28>
		list_insert_as_head(list, new_task);
 232:	4b10      	ldr	r3, [pc, #64]	; (274 <timer_add_timer_task+0x50>)
 234:	4798      	blx	r3
		return;
 236:	e018      	b.n	26a <timer_add_timer_task+0x46>
		uint32_t time_left;

		if (it->time_label <= time) {
			time_left = it->interval - (time - it->time_label);
		} else {
			time_left = it->interval - (0xFFFFFFFF - it->time_label) - time;
 238:	689f      	ldr	r7, [r3, #8]
 23a:	46bc      	mov	ip, r7
 23c:	4464      	add	r4, ip
 23e:	1aa4      	subs	r4, r4, r2
 240:	3401      	adds	r4, #1
		}
		if (time_left >= new_task->interval)
 242:	688f      	ldr	r7, [r1, #8]
 244:	42bc      	cmp	r4, r7
 246:	d20b      	bcs.n	260 <timer_add_timer_task+0x3c>
			break;
		prev = it;
 248:	001d      	movs	r5, r3
	for (it = head; it; it = (struct timer_task *)list_get_next_element(it)) {
 24a:	681b      	ldr	r3, [r3, #0]
 24c:	2b00      	cmp	r3, #0
 24e:	d007      	beq.n	260 <timer_add_timer_task+0x3c>
		if (it->time_label <= time) {
 250:	685c      	ldr	r4, [r3, #4]
 252:	4294      	cmp	r4, r2
 254:	d8f0      	bhi.n	238 <timer_add_timer_task+0x14>
			time_left = it->interval - (time - it->time_label);
 256:	1aa4      	subs	r4, r4, r2
 258:	689f      	ldr	r7, [r3, #8]
 25a:	46bc      	mov	ip, r7
 25c:	4464      	add	r4, ip
 25e:	e7f0      	b.n	242 <timer_add_timer_task+0x1e>
	}

	if (it == head) {
 260:	42b3      	cmp	r3, r6
 262:	d003      	beq.n	26c <timer_add_timer_task+0x48>
		list_insert_as_head(list, new_task);
	} else {
		list_insert_after(prev, new_task);
 264:	0028      	movs	r0, r5
 266:	4b04      	ldr	r3, [pc, #16]	; (278 <timer_add_timer_task+0x54>)
 268:	4798      	blx	r3
	}
}
 26a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		list_insert_as_head(list, new_task);
 26c:	4b01      	ldr	r3, [pc, #4]	; (274 <timer_add_timer_task+0x50>)
 26e:	4798      	blx	r3
 270:	e7fb      	b.n	26a <timer_add_timer_task+0x46>
 272:	46c0      	nop			; (mov r8, r8)
 274:	00000431 	.word	0x00000431
 278:	0000045d 	.word	0x0000045d

0000027c <timer_process_counted>:

/**
 * \internal Process interrupts
 */
static void timer_process_counted(struct _timer_device *device)
{
 27c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 27e:	0005      	movs	r5, r0
 280:	6944      	ldr	r4, [r0, #20]
	struct timer_descriptor *timer = CONTAINER_OF(device, struct timer_descriptor, device);
	struct timer_task *      it    = (struct timer_task *)list_get_head(&timer->tasks);
	uint32_t                 time  = ++timer->time;
 282:	6903      	ldr	r3, [r0, #16]
 284:	1c5e      	adds	r6, r3, #1
 286:	6106      	str	r6, [r0, #16]

	if ((timer->flags & TIMER_FLAG_QUEUE_IS_TAKEN) || (timer->flags & TIMER_FLAG_INTERRUPT_TRIGERRED)) {
 288:	7e03      	ldrb	r3, [r0, #24]
 28a:	07db      	lsls	r3, r3, #31
 28c:	d402      	bmi.n	294 <timer_process_counted+0x18>
 28e:	7e03      	ldrb	r3, [r0, #24]
 290:	079b      	lsls	r3, r3, #30
 292:	d50a      	bpl.n	2aa <timer_process_counted+0x2e>
		timer->flags |= TIMER_FLAG_INTERRUPT_TRIGERRED;
 294:	7e2b      	ldrb	r3, [r5, #24]
 296:	2202      	movs	r2, #2
 298:	4313      	orrs	r3, r2
 29a:	b2db      	uxtb	r3, r3
 29c:	762b      	strb	r3, [r5, #24]
		}
		it = (struct timer_task *)list_get_head(&timer->tasks);

		tmp->cb(tmp);
	}
}
 29e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 2a0:	696f      	ldr	r7, [r5, #20]
		tmp->cb(tmp);
 2a2:	68e3      	ldr	r3, [r4, #12]
 2a4:	0020      	movs	r0, r4
 2a6:	4798      	blx	r3
		it = (struct timer_task *)list_get_head(&timer->tasks);
 2a8:	003c      	movs	r4, r7
	while (it && ((time - it->time_label) >= it->interval)) {
 2aa:	2c00      	cmp	r4, #0
 2ac:	d0f7      	beq.n	29e <timer_process_counted+0x22>
 2ae:	6863      	ldr	r3, [r4, #4]
 2b0:	1af3      	subs	r3, r6, r3
 2b2:	68a2      	ldr	r2, [r4, #8]
 2b4:	4293      	cmp	r3, r2
 2b6:	d3f2      	bcc.n	29e <timer_process_counted+0x22>
		list_remove_head(&timer->tasks);
 2b8:	002f      	movs	r7, r5
 2ba:	3714      	adds	r7, #20
 2bc:	0038      	movs	r0, r7
 2be:	4b06      	ldr	r3, [pc, #24]	; (2d8 <timer_process_counted+0x5c>)
 2c0:	4798      	blx	r3
		if (TIMER_TASK_REPEAT == tmp->mode) {
 2c2:	7c23      	ldrb	r3, [r4, #16]
 2c4:	2b01      	cmp	r3, #1
 2c6:	d1eb      	bne.n	2a0 <timer_process_counted+0x24>
			tmp->time_label = time;
 2c8:	6066      	str	r6, [r4, #4]
			timer_add_timer_task(&timer->tasks, tmp, time);
 2ca:	0032      	movs	r2, r6
 2cc:	0021      	movs	r1, r4
 2ce:	0038      	movs	r0, r7
 2d0:	4b02      	ldr	r3, [pc, #8]	; (2dc <timer_process_counted+0x60>)
 2d2:	4798      	blx	r3
 2d4:	e7e4      	b.n	2a0 <timer_process_counted+0x24>
 2d6:	46c0      	nop			; (mov r8, r8)
 2d8:	00000465 	.word	0x00000465
 2dc:	00000225 	.word	0x00000225

000002e0 <timer_init>:
{
 2e0:	b570      	push	{r4, r5, r6, lr}
 2e2:	0004      	movs	r4, r0
 2e4:	000d      	movs	r5, r1
	ASSERT(descr && hw);
 2e6:	2800      	cmp	r0, #0
 2e8:	d012      	beq.n	310 <timer_init+0x30>
 2ea:	2900      	cmp	r1, #0
 2ec:	d00e      	beq.n	30c <timer_init+0x2c>
 2ee:	2001      	movs	r0, #1
 2f0:	223b      	movs	r2, #59	; 0x3b
 2f2:	4908      	ldr	r1, [pc, #32]	; (314 <timer_init+0x34>)
 2f4:	4b08      	ldr	r3, [pc, #32]	; (318 <timer_init+0x38>)
 2f6:	4798      	blx	r3
	_timer_init(&descr->device, hw);
 2f8:	0029      	movs	r1, r5
 2fa:	0020      	movs	r0, r4
 2fc:	4b07      	ldr	r3, [pc, #28]	; (31c <timer_init+0x3c>)
 2fe:	4798      	blx	r3
	descr->time                           = 0;
 300:	2300      	movs	r3, #0
 302:	6123      	str	r3, [r4, #16]
	descr->device.timer_cb.period_expired = timer_process_counted;
 304:	4b06      	ldr	r3, [pc, #24]	; (320 <timer_init+0x40>)
 306:	6023      	str	r3, [r4, #0]
}
 308:	2000      	movs	r0, #0
 30a:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && hw);
 30c:	2000      	movs	r0, #0
 30e:	e7ef      	b.n	2f0 <timer_init+0x10>
 310:	2000      	movs	r0, #0
 312:	e7ed      	b.n	2f0 <timer_init+0x10>
 314:	000006e0 	.word	0x000006e0
 318:	00000411 	.word	0x00000411
 31c:	00000505 	.word	0x00000505
 320:	0000027d 	.word	0x0000027d

00000324 <timer_start>:
{
 324:	b510      	push	{r4, lr}
 326:	0004      	movs	r4, r0
	ASSERT(descr);
 328:	1e43      	subs	r3, r0, #1
 32a:	4198      	sbcs	r0, r3
 32c:	b2c0      	uxtb	r0, r0
 32e:	2253      	movs	r2, #83	; 0x53
 330:	4907      	ldr	r1, [pc, #28]	; (350 <timer_start+0x2c>)
 332:	4b08      	ldr	r3, [pc, #32]	; (354 <timer_start+0x30>)
 334:	4798      	blx	r3
	if (_timer_is_started(&descr->device)) {
 336:	0020      	movs	r0, r4
 338:	4b07      	ldr	r3, [pc, #28]	; (358 <timer_start+0x34>)
 33a:	4798      	blx	r3
 33c:	2800      	cmp	r0, #0
 33e:	d104      	bne.n	34a <timer_start+0x26>
	_timer_start(&descr->device);
 340:	0020      	movs	r0, r4
 342:	4b06      	ldr	r3, [pc, #24]	; (35c <timer_start+0x38>)
 344:	4798      	blx	r3
	return ERR_NONE;
 346:	2000      	movs	r0, #0
}
 348:	bd10      	pop	{r4, pc}
		return ERR_DENIED;
 34a:	2011      	movs	r0, #17
 34c:	4240      	negs	r0, r0
 34e:	e7fb      	b.n	348 <timer_start+0x24>
 350:	000006e0 	.word	0x000006e0
 354:	00000411 	.word	0x00000411
 358:	000005b9 	.word	0x000005b9
 35c:	00000561 	.word	0x00000561

00000360 <timer_add_task>:
{
 360:	b570      	push	{r4, r5, r6, lr}
 362:	b082      	sub	sp, #8
 364:	0004      	movs	r4, r0
 366:	000d      	movs	r5, r1
	ASSERT(descr && task);
 368:	2800      	cmp	r0, #0
 36a:	d026      	beq.n	3ba <timer_add_task+0x5a>
 36c:	2900      	cmp	r1, #0
 36e:	d022      	beq.n	3b6 <timer_add_task+0x56>
 370:	2001      	movs	r0, #1
 372:	227a      	movs	r2, #122	; 0x7a
 374:	491f      	ldr	r1, [pc, #124]	; (3f4 <timer_add_task+0x94>)
 376:	4b20      	ldr	r3, [pc, #128]	; (3f8 <timer_add_task+0x98>)
 378:	4798      	blx	r3
	descr->flags |= TIMER_FLAG_QUEUE_IS_TAKEN;
 37a:	7e23      	ldrb	r3, [r4, #24]
 37c:	2201      	movs	r2, #1
 37e:	4313      	orrs	r3, r2
 380:	b2db      	uxtb	r3, r3
 382:	7623      	strb	r3, [r4, #24]
	if (is_list_element(&descr->tasks, task)) {
 384:	0026      	movs	r6, r4
 386:	3614      	adds	r6, #20
 388:	0029      	movs	r1, r5
 38a:	0030      	movs	r0, r6
 38c:	4b1b      	ldr	r3, [pc, #108]	; (3fc <timer_add_task+0x9c>)
 38e:	4798      	blx	r3
 390:	2800      	cmp	r0, #0
 392:	d114      	bne.n	3be <timer_add_task+0x5e>
	task->time_label = descr->time;
 394:	6923      	ldr	r3, [r4, #16]
 396:	606b      	str	r3, [r5, #4]
	timer_add_timer_task(&descr->tasks, task, descr->time);
 398:	6922      	ldr	r2, [r4, #16]
 39a:	0029      	movs	r1, r5
 39c:	0030      	movs	r0, r6
 39e:	4b18      	ldr	r3, [pc, #96]	; (400 <timer_add_task+0xa0>)
 3a0:	4798      	blx	r3
	descr->flags &= ~TIMER_FLAG_QUEUE_IS_TAKEN;
 3a2:	7e23      	ldrb	r3, [r4, #24]
 3a4:	2201      	movs	r2, #1
 3a6:	4393      	bics	r3, r2
 3a8:	7623      	strb	r3, [r4, #24]
	if (descr->flags & TIMER_FLAG_INTERRUPT_TRIGERRED) {
 3aa:	7e23      	ldrb	r3, [r4, #24]
 3ac:	079b      	lsls	r3, r3, #30
 3ae:	d412      	bmi.n	3d6 <timer_add_task+0x76>
	return ERR_NONE;
 3b0:	2000      	movs	r0, #0
}
 3b2:	b002      	add	sp, #8
 3b4:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && task);
 3b6:	2000      	movs	r0, #0
 3b8:	e7db      	b.n	372 <timer_add_task+0x12>
 3ba:	2000      	movs	r0, #0
 3bc:	e7d9      	b.n	372 <timer_add_task+0x12>
		descr->flags &= ~TIMER_FLAG_QUEUE_IS_TAKEN;
 3be:	7e23      	ldrb	r3, [r4, #24]
 3c0:	2201      	movs	r2, #1
 3c2:	4393      	bics	r3, r2
 3c4:	7623      	strb	r3, [r4, #24]
		ASSERT(false);
 3c6:	327e      	adds	r2, #126	; 0x7e
 3c8:	490a      	ldr	r1, [pc, #40]	; (3f4 <timer_add_task+0x94>)
 3ca:	2000      	movs	r0, #0
 3cc:	4b0a      	ldr	r3, [pc, #40]	; (3f8 <timer_add_task+0x98>)
 3ce:	4798      	blx	r3
		return ERR_ALREADY_INITIALIZED;
 3d0:	2012      	movs	r0, #18
 3d2:	4240      	negs	r0, r0
 3d4:	e7ed      	b.n	3b2 <timer_add_task+0x52>
		CRITICAL_SECTION_ENTER()
 3d6:	a801      	add	r0, sp, #4
 3d8:	4b0a      	ldr	r3, [pc, #40]	; (404 <timer_add_task+0xa4>)
 3da:	4798      	blx	r3
		descr->flags &= ~TIMER_FLAG_INTERRUPT_TRIGERRED;
 3dc:	7e23      	ldrb	r3, [r4, #24]
 3de:	2202      	movs	r2, #2
 3e0:	4393      	bics	r3, r2
 3e2:	7623      	strb	r3, [r4, #24]
		_timer_set_irq(&descr->device);
 3e4:	0020      	movs	r0, r4
 3e6:	4b08      	ldr	r3, [pc, #32]	; (408 <timer_add_task+0xa8>)
 3e8:	4798      	blx	r3
		CRITICAL_SECTION_LEAVE()
 3ea:	a801      	add	r0, sp, #4
 3ec:	4b07      	ldr	r3, [pc, #28]	; (40c <timer_add_task+0xac>)
 3ee:	4798      	blx	r3
	return ERR_NONE;
 3f0:	2000      	movs	r0, #0
 3f2:	e7de      	b.n	3b2 <timer_add_task+0x52>
 3f4:	000006e0 	.word	0x000006e0
 3f8:	00000411 	.word	0x00000411
 3fc:	00000419 	.word	0x00000419
 400:	00000225 	.word	0x00000225
 404:	00000209 	.word	0x00000209
 408:	000005cb 	.word	0x000005cb
 40c:	00000217 	.word	0x00000217

00000410 <assert>:
/**
 * \brief Assert function
 */
void assert(const bool condition, const char *const file, const int line)
{
	if (!(condition)) {
 410:	2800      	cmp	r0, #0
 412:	d100      	bne.n	416 <assert+0x6>
		__asm("BKPT #0");
 414:	be00      	bkpt	0x0000
	}
	(void)file;
	(void)line;
}
 416:	4770      	bx	lr

00000418 <is_list_element>:
 * \brief Check whether element belongs to list
 */
bool is_list_element(const struct list_descriptor *const list, const void *const element)
{
	struct list_element *it;
	for (it = list->head; it; it = it->next) {
 418:	6803      	ldr	r3, [r0, #0]
 41a:	2b00      	cmp	r3, #0
 41c:	d003      	beq.n	426 <is_list_element+0xe>
		if (it == element) {
 41e:	428b      	cmp	r3, r1
 420:	d003      	beq.n	42a <is_list_element+0x12>
	for (it = list->head; it; it = it->next) {
 422:	681b      	ldr	r3, [r3, #0]
 424:	e7f9      	b.n	41a <is_list_element+0x2>
			return true;
		}
	}

	return false;
 426:	2000      	movs	r0, #0
}
 428:	4770      	bx	lr
			return true;
 42a:	2001      	movs	r0, #1
 42c:	e7fc      	b.n	428 <is_list_element+0x10>
	...

00000430 <list_insert_as_head>:

/**
 * \brief Insert an element as list head
 */
void list_insert_as_head(struct list_descriptor *const list, void *const element)
{
 430:	b570      	push	{r4, r5, r6, lr}
 432:	0004      	movs	r4, r0
 434:	000d      	movs	r5, r1
	ASSERT(!is_list_element(list, element));
 436:	4b06      	ldr	r3, [pc, #24]	; (450 <list_insert_as_head+0x20>)
 438:	4798      	blx	r3
 43a:	2301      	movs	r3, #1
 43c:	4058      	eors	r0, r3
 43e:	b2c0      	uxtb	r0, r0
 440:	2239      	movs	r2, #57	; 0x39
 442:	4904      	ldr	r1, [pc, #16]	; (454 <list_insert_as_head+0x24>)
 444:	4b04      	ldr	r3, [pc, #16]	; (458 <list_insert_as_head+0x28>)
 446:	4798      	blx	r3

	((struct list_element *)element)->next = list->head;
 448:	6823      	ldr	r3, [r4, #0]
 44a:	602b      	str	r3, [r5, #0]
	list->head                             = (struct list_element *)element;
 44c:	6025      	str	r5, [r4, #0]
}
 44e:	bd70      	pop	{r4, r5, r6, pc}
 450:	00000419 	.word	0x00000419
 454:	000006f8 	.word	0x000006f8
 458:	00000411 	.word	0x00000411

0000045c <list_insert_after>:
/**
 * \brief Insert an element after the given list element
 */
void list_insert_after(void *const after, void *const element)
{
	((struct list_element *)element)->next = ((struct list_element *)after)->next;
 45c:	6803      	ldr	r3, [r0, #0]
 45e:	600b      	str	r3, [r1, #0]
	((struct list_element *)after)->next   = (struct list_element *)element;
 460:	6001      	str	r1, [r0, #0]
}
 462:	4770      	bx	lr

00000464 <list_remove_head>:
/**
 * \brief Removes list head
 */
void *list_remove_head(struct list_descriptor *const list)
{
	if (list->head) {
 464:	6803      	ldr	r3, [r0, #0]
 466:	2b00      	cmp	r3, #0
 468:	d003      	beq.n	472 <list_remove_head+0xe>
		struct list_element *tmp = list->head;

		list->head = list->head->next;
 46a:	681a      	ldr	r2, [r3, #0]
 46c:	6002      	str	r2, [r0, #0]
		return (void *)tmp;
 46e:	0018      	movs	r0, r3
	}

	return NULL;
}
 470:	4770      	bx	lr
	return NULL;
 472:	2000      	movs	r0, #0
 474:	e7fc      	b.n	470 <list_remove_head+0xc>
	...

00000478 <_init_chip>:

/**
 * \brief Initialize the hardware abstraction layer
 */
void _init_chip(void)
{
 478:	b510      	push	{r4, lr}
}

static inline void hri_nvmctrl_set_CTRLB_RWS_bf(const void *const hw, hri_nvmctrl_ctrlb_reg_t mask)
{
	NVMCTRL_CRITICAL_SECTION_ENTER();
	((Nvmctrl *)hw)->CTRLB.reg |= NVMCTRL_CTRLB_RWS(mask);
 47a:	4b06      	ldr	r3, [pc, #24]	; (494 <_init_chip+0x1c>)
 47c:	685a      	ldr	r2, [r3, #4]
 47e:	605a      	str	r2, [r3, #4]
	hri_nvmctrl_set_CTRLB_RWS_bf(NVMCTRL, CONF_NVM_WAIT_STATE);

	_pm_init();
 480:	4b05      	ldr	r3, [pc, #20]	; (498 <_init_chip+0x20>)
 482:	4798      	blx	r3
	_sysctrl_init_sources();
 484:	4b05      	ldr	r3, [pc, #20]	; (49c <_init_chip+0x24>)
 486:	4798      	blx	r3
#if _GCLK_INIT_1ST
	_gclk_init_generators_by_fref(_GCLK_INIT_1ST);
#endif
	_sysctrl_init_referenced_generators();
 488:	4b05      	ldr	r3, [pc, #20]	; (4a0 <_init_chip+0x28>)
 48a:	4798      	blx	r3
	_gclk_init_generators_by_fref(_GCLK_INIT_LAST);
 48c:	20ff      	movs	r0, #255	; 0xff
 48e:	4b05      	ldr	r3, [pc, #20]	; (4a4 <_init_chip+0x2c>)
 490:	4798      	blx	r3
}
 492:	bd10      	pop	{r4, pc}
 494:	41004000 	.word	0x41004000
 498:	000004c9 	.word	0x000004c9
 49c:	000005e5 	.word	0x000005e5
 4a0:	00000631 	.word	0x00000631
 4a4:	000004a9 	.word	0x000004a9

000004a8 <_gclk_init_generators_by_fref>:

void _gclk_init_generators_by_fref(uint32_t bm)
{

#if CONF_GCLK_GENERATOR_0_CONFIG == 1
	if (bm & (1ul << 0)) {
 4a8:	07c3      	lsls	r3, r0, #31
 4aa:	d50a      	bpl.n	4c2 <_gclk_init_generators_by_fref+0x1a>
}

static inline void hri_gclk_write_GENDIV_reg(const void *const hw, hri_gclk_gendiv_reg_t data)
{
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->GENDIV.reg = data;
 4ac:	4b05      	ldr	r3, [pc, #20]	; (4c4 <_gclk_init_generators_by_fref+0x1c>)
 4ae:	2280      	movs	r2, #128	; 0x80
 4b0:	0052      	lsls	r2, r2, #1
 4b2:	609a      	str	r2, [r3, #8]
	((Gclk *)hw)->GENCTRL.reg = data;
 4b4:	2283      	movs	r2, #131	; 0x83
 4b6:	0252      	lsls	r2, r2, #9
 4b8:	605a      	str	r2, [r3, #4]
	while (((const Gclk *)hw)->STATUS.bit.SYNCBUSY)
 4ba:	4b02      	ldr	r3, [pc, #8]	; (4c4 <_gclk_init_generators_by_fref+0x1c>)
 4bc:	785b      	ldrb	r3, [r3, #1]
 4be:	09db      	lsrs	r3, r3, #7
 4c0:	d1fb      	bne.n	4ba <_gclk_init_generators_by_fref+0x12>
		        | (CONF_GCLK_GEN_7_DIVSEL << GCLK_GENCTRL_DIVSEL_Pos) | (CONF_GCLK_GEN_7_OE << GCLK_GENCTRL_OE_Pos)
		        | (CONF_GCLK_GEN_7_OOV << GCLK_GENCTRL_OOV_Pos) | (CONF_GCLK_GEN_7_IDC << GCLK_GENCTRL_IDC_Pos)
		        | (CONF_GCLK_GENERATOR_7_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_7_SRC | GCLK_GENCTRL_ID(7));
	}
#endif
}
 4c2:	4770      	bx	lr
 4c4:	40000c00 	.word	0x40000c00

000004c8 <_pm_init>:
}

static inline void hri_pm_set_CPUSEL_CPUDIV_bf(const void *const hw, hri_pm_cpusel_reg_t mask)
{
	PM_CRITICAL_SECTION_ENTER();
	((Pm *)hw)->CPUSEL.reg |= PM_CPUSEL_CPUDIV(mask);
 4c8:	4b06      	ldr	r3, [pc, #24]	; (4e4 <_pm_init+0x1c>)
 4ca:	7a1a      	ldrb	r2, [r3, #8]
 4cc:	b2d2      	uxtb	r2, r2
 4ce:	721a      	strb	r2, [r3, #8]
}

static inline void hri_pm_set_APBASEL_APBADIV_bf(const void *const hw, hri_pm_apbasel_reg_t mask)
{
	PM_CRITICAL_SECTION_ENTER();
	((Pm *)hw)->APBASEL.reg |= PM_APBASEL_APBADIV(mask);
 4d0:	7a5a      	ldrb	r2, [r3, #9]
 4d2:	b2d2      	uxtb	r2, r2
 4d4:	725a      	strb	r2, [r3, #9]
}

static inline void hri_pm_set_APBBSEL_APBBDIV_bf(const void *const hw, hri_pm_apbbsel_reg_t mask)
{
	PM_CRITICAL_SECTION_ENTER();
	((Pm *)hw)->APBBSEL.reg |= PM_APBBSEL_APBBDIV(mask);
 4d6:	7a9a      	ldrb	r2, [r3, #10]
 4d8:	b2d2      	uxtb	r2, r2
 4da:	729a      	strb	r2, [r3, #10]
}

static inline void hri_pm_set_APBCSEL_APBCDIV_bf(const void *const hw, hri_pm_apbcsel_reg_t mask)
{
	PM_CRITICAL_SECTION_ENTER();
	((Pm *)hw)->APBCSEL.reg |= PM_APBCSEL_APBCDIV(mask);
 4dc:	7ada      	ldrb	r2, [r3, #11]
 4de:	b2d2      	uxtb	r2, r2
 4e0:	72da      	strb	r2, [r3, #11]
{
	hri_pm_set_CPUSEL_CPUDIV_bf(PM, CONF_CPU_DIV);
	hri_pm_set_APBASEL_APBADIV_bf(PM, CONF_APBA_DIV);
	hri_pm_set_APBBSEL_APBBDIV_bf(PM, CONF_APBB_DIV);
	hri_pm_set_APBCSEL_APBCDIV_bf(PM, CONF_APBC_DIV);
}
 4e2:	4770      	bx	lr
 4e4:	40000400 	.word	0x40000400

000004e8 <_rtc_timer_interrupt_handler>:
 * \brief RTC Timer interrupt handler
 *
 * \param[in] p The pointer to calendar device struct
 */
static void _rtc_timer_interrupt_handler(struct _timer_device *dev)
{
 4e8:	b510      	push	{r4, lr}
 4ea:	0004      	movs	r4, r0
	return tmp;
}

static inline hri_rtcmode0_intflag_reg_t hri_rtcmode0_read_INTFLAG_reg(const void *const hw)
{
	return ((Rtc *)hw)->MODE0.INTFLAG.reg;
 4ec:	68c3      	ldr	r3, [r0, #12]
 4ee:	7a1b      	ldrb	r3, [r3, #8]
	/* Read and mask interrupt flag register */
	uint16_t flag = hri_rtcmode0_read_INTFLAG_reg(dev->hw);

	if (flag & RTC_MODE0_INTFLAG_CMP0) {
 4f0:	07db      	lsls	r3, r3, #31
 4f2:	d506      	bpl.n	502 <_rtc_timer_interrupt_handler+0x1a>
		if (dev->timer_cb.period_expired) {
 4f4:	6803      	ldr	r3, [r0, #0]
 4f6:	2b00      	cmp	r3, #0
 4f8:	d000      	beq.n	4fc <_rtc_timer_interrupt_handler+0x14>
			dev->timer_cb.period_expired(dev);
 4fa:	4798      	blx	r3
		}

		/* Clear interrupt flag */
		hri_rtcmode0_clear_interrupt_CMP0_bit(dev->hw);
 4fc:	68e3      	ldr	r3, [r4, #12]
	((Rtc *)hw)->MODE0.INTFLAG.reg = RTC_MODE0_INTFLAG_CMP0;
 4fe:	2201      	movs	r2, #1
 500:	721a      	strb	r2, [r3, #8]
	}
}
 502:	bd10      	pop	{r4, pc}

00000504 <_timer_init>:
{
 504:	b570      	push	{r4, r5, r6, lr}
 506:	0004      	movs	r4, r0
 508:	000d      	movs	r5, r1
	ASSERT(dev);
 50a:	1e43      	subs	r3, r0, #1
 50c:	4198      	sbcs	r0, r3
 50e:	b2c0      	uxtb	r0, r0
 510:	2230      	movs	r2, #48	; 0x30
 512:	4910      	ldr	r1, [pc, #64]	; (554 <_timer_init+0x50>)
 514:	4b10      	ldr	r3, [pc, #64]	; (558 <_timer_init+0x54>)
 516:	4798      	blx	r3
	dev->hw = hw;
 518:	60e5      	str	r5, [r4, #12]
}

static inline void hri_rtcmode0_write_CTRL_reg(const void *const hw, hri_rtcmode0_ctrl_reg_t data)
{
	RTC_CRITICAL_SECTION_ENTER();
	((Rtc *)hw)->MODE0.CTRL.reg = data;
 51a:	2301      	movs	r3, #1
 51c:	802b      	strh	r3, [r5, #0]
	while (((const Rtc *)hw)->MODE0.STATUS.bit.SYNCBUSY)
 51e:	7aab      	ldrb	r3, [r5, #10]
 520:	09db      	lsrs	r3, r3, #7
 522:	d1fc      	bne.n	51e <_timer_init+0x1a>
	hri_rtcmode0_wait_for_sync(dev->hw);
 524:	68e2      	ldr	r2, [r4, #12]
 526:	7a93      	ldrb	r3, [r2, #10]
 528:	09db      	lsrs	r3, r3, #7
 52a:	d1fc      	bne.n	526 <_timer_init+0x22>
	((Rtc *)hw)->MODE0.CTRL.reg = data;
 52c:	3380      	adds	r3, #128	; 0x80
 52e:	8013      	strh	r3, [r2, #0]
	while (((const Rtc *)hw)->MODE0.STATUS.bit.SYNCBUSY)
 530:	7a93      	ldrb	r3, [r2, #10]
 532:	09db      	lsrs	r3, r3, #7
 534:	d1fc      	bne.n	530 <_timer_init+0x2c>
	hri_rtcmode0_write_COMP_COMP_bf(dev->hw, 0, CONF_RTC_COMP_VAL);
 536:	68e2      	ldr	r2, [r4, #12]

static inline void hri_rtcmode0_write_COMP_COMP_bf(const void *const hw, uint8_t index, hri_rtcmode0_comp_reg_t data)
{
	uint32_t tmp;
	RTC_CRITICAL_SECTION_ENTER();
	tmp = ((Rtc *)hw)->MODE0.COMP[index].reg;
 538:	6993      	ldr	r3, [r2, #24]
	tmp &= ~RTC_MODE0_COMP_COMP_Msk;
	tmp |= RTC_MODE0_COMP_COMP(data);
	((Rtc *)hw)->MODE0.COMP[index].reg = tmp;
 53a:	2380      	movs	r3, #128	; 0x80
 53c:	00db      	lsls	r3, r3, #3
 53e:	6193      	str	r3, [r2, #24]
	while (((const Rtc *)hw)->MODE0.STATUS.bit.SYNCBUSY)
 540:	7a93      	ldrb	r3, [r2, #10]
 542:	09db      	lsrs	r3, r3, #7
 544:	d1fc      	bne.n	540 <_timer_init+0x3c>
	((Rtc *)hw)->MODE0.INTENSET.reg = RTC_MODE0_INTENSET_CMP0;
 546:	3301      	adds	r3, #1
 548:	68e2      	ldr	r2, [r4, #12]
 54a:	71d3      	strb	r3, [r2, #7]
	_rtc_dev = dev;
 54c:	4b03      	ldr	r3, [pc, #12]	; (55c <_timer_init+0x58>)
 54e:	601c      	str	r4, [r3, #0]
}
 550:	2000      	movs	r0, #0
 552:	bd70      	pop	{r4, r5, r6, pc}
 554:	00000718 	.word	0x00000718
 558:	00000411 	.word	0x00000411
 55c:	2000001c 	.word	0x2000001c

00000560 <_timer_start>:
{
 560:	b510      	push	{r4, lr}
 562:	1e04      	subs	r4, r0, #0
	ASSERT(dev && dev->hw);
 564:	d020      	beq.n	5a8 <_timer_start+0x48>
 566:	68c3      	ldr	r3, [r0, #12]
 568:	2b00      	cmp	r3, #0
 56a:	d01b      	beq.n	5a4 <_timer_start+0x44>
 56c:	2001      	movs	r0, #1
 56e:	2267      	movs	r2, #103	; 0x67
 570:	490e      	ldr	r1, [pc, #56]	; (5ac <_timer_start+0x4c>)
 572:	4b0f      	ldr	r3, [pc, #60]	; (5b0 <_timer_start+0x50>)
 574:	4798      	blx	r3
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 576:	2208      	movs	r2, #8
 578:	4b0e      	ldr	r3, [pc, #56]	; (5b4 <_timer_start+0x54>)
 57a:	601a      	str	r2, [r3, #0]
	hri_rtcmode0_write_COUNT_COUNT_bf(dev->hw, 0);
 57c:	68e2      	ldr	r2, [r4, #12]
	tmp = ((Rtc *)hw)->MODE0.COUNT.reg;
 57e:	6913      	ldr	r3, [r2, #16]
	((Rtc *)hw)->MODE0.COUNT.reg = tmp;
 580:	2300      	movs	r3, #0
 582:	6113      	str	r3, [r2, #16]
	while (((const Rtc *)hw)->MODE0.STATUS.bit.SYNCBUSY)
 584:	7a93      	ldrb	r3, [r2, #10]
 586:	09db      	lsrs	r3, r3, #7
 588:	d1fc      	bne.n	584 <_timer_start+0x24>
	hri_rtcmode0_wait_for_sync(dev->hw);
 58a:	68e2      	ldr	r2, [r4, #12]
 58c:	7a93      	ldrb	r3, [r2, #10]
 58e:	09db      	lsrs	r3, r3, #7
 590:	d1fc      	bne.n	58c <_timer_start+0x2c>
	((Rtc *)hw)->MODE0.CTRL.reg |= RTC_MODE0_CTRL_ENABLE;
 592:	8813      	ldrh	r3, [r2, #0]
 594:	2102      	movs	r1, #2
 596:	430b      	orrs	r3, r1
 598:	b29b      	uxth	r3, r3
 59a:	8013      	strh	r3, [r2, #0]
	while (((const Rtc *)hw)->MODE0.STATUS.bit.SYNCBUSY)
 59c:	7a93      	ldrb	r3, [r2, #10]
 59e:	09db      	lsrs	r3, r3, #7
 5a0:	d1fc      	bne.n	59c <_timer_start+0x3c>
}
 5a2:	bd10      	pop	{r4, pc}
	ASSERT(dev && dev->hw);
 5a4:	2000      	movs	r0, #0
 5a6:	e7e2      	b.n	56e <_timer_start+0xe>
 5a8:	2000      	movs	r0, #0
 5aa:	e7e0      	b.n	56e <_timer_start+0xe>
 5ac:	00000718 	.word	0x00000718
 5b0:	00000411 	.word	0x00000411
 5b4:	e000e100 	.word	0xe000e100

000005b8 <_timer_is_started>:
	return hri_rtcmode0_get_CTRL_ENABLE_bit(dev->hw);
 5b8:	68c2      	ldr	r2, [r0, #12]
 5ba:	7a93      	ldrb	r3, [r2, #10]
 5bc:	09db      	lsrs	r3, r3, #7
 5be:	d1fc      	bne.n	5ba <_timer_is_started+0x2>
	tmp = ((Rtc *)hw)->MODE0.CTRL.reg;
 5c0:	8813      	ldrh	r3, [r2, #0]
	tmp = (tmp & RTC_MODE0_CTRL_ENABLE) >> RTC_MODE0_CTRL_ENABLE_Pos;
 5c2:	085b      	lsrs	r3, r3, #1
	return (bool)tmp;
 5c4:	2001      	movs	r0, #1
 5c6:	4018      	ands	r0, r3
}
 5c8:	4770      	bx	lr

000005ca <_timer_set_irq>:
}
 5ca:	4770      	bx	lr

000005cc <_rtc_get_timer>:
 * \brief Retrieve timer helper functions
 */
struct _timer_hpl_interface *_rtc_get_timer(void)
{
	return NULL;
}
 5cc:	2000      	movs	r0, #0
 5ce:	4770      	bx	lr

000005d0 <RTC_Handler>:

/**
 * \brief Rtc interrupt handler
 */
void RTC_Handler(void)
{
 5d0:	b510      	push	{r4, lr}
	_rtc_timer_interrupt_handler(_rtc_dev);
 5d2:	4b02      	ldr	r3, [pc, #8]	; (5dc <RTC_Handler+0xc>)
 5d4:	6818      	ldr	r0, [r3, #0]
 5d6:	4b02      	ldr	r3, [pc, #8]	; (5e0 <RTC_Handler+0x10>)
 5d8:	4798      	blx	r3
}
 5da:	bd10      	pop	{r4, pc}
 5dc:	2000001c 	.word	0x2000001c
 5e0:	000004e9 	.word	0x000004e9

000005e4 <_sysctrl_init_sources>:
}

static inline hri_sysctrl_osc8m_reg_t hri_sysctrl_read_OSC8M_CALIB_bf(const void *const hw)
{
	uint32_t tmp;
	tmp = ((Sysctrl *)hw)->OSC8M.reg;
 5e4:	4b0f      	ldr	r3, [pc, #60]	; (624 <_sysctrl_init_sources+0x40>)
 5e6:	6a19      	ldr	r1, [r3, #32]
	tmp = (tmp & SYSCTRL_OSC8M_CALIB_Msk) >> SYSCTRL_OSC8M_CALIB_Pos;
 5e8:	0c09      	lsrs	r1, r1, #16
}

static inline hri_sysctrl_osc8m_reg_t hri_sysctrl_read_OSC8M_FRANGE_bf(const void *const hw)
{
	uint32_t tmp;
	tmp = ((Sysctrl *)hw)->OSC8M.reg;
 5ea:	6a1a      	ldr	r2, [r3, #32]

#if CONF_OSC8M_CONFIG == 1
	calib = hri_sysctrl_read_OSC8M_CALIB_bf(hw);

	hri_sysctrl_write_OSC8M_reg(hw,
	                            SYSCTRL_OSC8M_FRANGE(hri_sysctrl_read_OSC8M_FRANGE_bf(hw)) |
 5ec:	0f92      	lsrs	r2, r2, #30
 5ee:	0792      	lsls	r2, r2, #30
#if CONF_OSC8M_OVERWRITE_CALIBRATION == 1
	                                SYSCTRL_OSC8M_CALIB(CONF_OSC8M_CALIB) |
#else
	                                SYSCTRL_OSC8M_CALIB(calib) |
 5f0:	0409      	lsls	r1, r1, #16
 5f2:	480d      	ldr	r0, [pc, #52]	; (628 <_sysctrl_init_sources+0x44>)
 5f4:	4001      	ands	r1, r0
	                            SYSCTRL_OSC8M_FRANGE(hri_sysctrl_read_OSC8M_FRANGE_bf(hw)) |
 5f6:	430a      	orrs	r2, r1
	hri_sysctrl_write_OSC8M_reg(hw,
 5f8:	490c      	ldr	r1, [pc, #48]	; (62c <_sysctrl_init_sources+0x48>)
 5fa:	430a      	orrs	r2, r1
}

static inline void hri_sysctrl_write_OSC8M_reg(const void *const hw, hri_sysctrl_osc8m_reg_t data)
{
	SYSCTRL_CRITICAL_SECTION_ENTER();
	((Sysctrl *)hw)->OSC8M.reg = data;
 5fc:	621a      	str	r2, [r3, #32]
	((Sysctrl *)hw)->OSC32K.reg |= SYSCTRL_OSC32K_ENABLE;
 5fe:	699a      	ldr	r2, [r3, #24]
 600:	2102      	movs	r1, #2
 602:	430a      	orrs	r2, r1
 604:	619a      	str	r2, [r3, #24]
	tmp = ((Sysctrl *)hw)->OSCULP32K.reg;
 606:	7f1a      	ldrb	r2, [r3, #28]
	tmp = (tmp & SYSCTRL_OSCULP32K_CALIB_Msk) >> SYSCTRL_OSCULP32K_CALIB_Pos;
 608:	311d      	adds	r1, #29
 60a:	400a      	ands	r2, r1
	((Sysctrl *)hw)->OSCULP32K.reg = data;
 60c:	771a      	strb	r2, [r3, #28]
	return (((Sysctrl *)hw)->PCLKSR.reg & SYSCTRL_PCLKSR_OSC8MRDY) >> SYSCTRL_PCLKSR_OSC8MRDY_Pos;
 60e:	4b05      	ldr	r3, [pc, #20]	; (624 <_sysctrl_init_sources+0x40>)
 610:	68db      	ldr	r3, [r3, #12]
#endif
#endif

#if CONF_OSC8M_CONFIG == 1
#if CONF_OSC8M_ENABLE == 1
	while (!hri_sysctrl_get_PCLKSR_OSC8MRDY_bit(hw))
 612:	071b      	lsls	r3, r3, #28
 614:	d5fb      	bpl.n	60e <_sysctrl_init_sources+0x2a>
	((Sysctrl *)hw)->OSC8M.reg |= SYSCTRL_OSC8M_ONDEMAND;
 616:	4a03      	ldr	r2, [pc, #12]	; (624 <_sysctrl_init_sources+0x40>)
 618:	6a13      	ldr	r3, [r2, #32]
 61a:	2180      	movs	r1, #128	; 0x80
 61c:	430b      	orrs	r3, r1
 61e:	6213      	str	r3, [r2, #32]
	hri_sysctrl_set_OSC8M_ONDEMAND_bit(hw);
#endif
#endif

	(void)calib, (void)hw;
}
 620:	4770      	bx	lr
 622:	46c0      	nop			; (mov r8, r8)
 624:	40000800 	.word	0x40000800
 628:	0fff0000 	.word	0x0fff0000
 62c:	00000302 	.word	0x00000302

00000630 <_sysctrl_init_referenced_generators>:
	((Sysctrl *)hw)->OSC32K.reg &= ~SYSCTRL_OSC32K_ENABLE;
 630:	4a02      	ldr	r2, [pc, #8]	; (63c <_sysctrl_init_referenced_generators+0xc>)
 632:	6993      	ldr	r3, [r2, #24]
 634:	2102      	movs	r1, #2
 636:	438b      	bics	r3, r1
 638:	6193      	str	r3, [r2, #24]
	/* Disable after all possible configurations needs sync written. */
	hri_sysctrl_clear_OSC32K_ENABLE_bit(hw);
#endif

	(void)hw;
}
 63a:	4770      	bx	lr
 63c:	40000800 	.word	0x40000800

00000640 <TIMER_0_task1_cb>:
	((Port *)hw)->Group[submodule_index].OUTTGL.reg = mask;
 640:	2280      	movs	r2, #128	; 0x80
 642:	01d2      	lsls	r2, r2, #7
 644:	23c0      	movs	r3, #192	; 0xc0
 646:	05db      	lsls	r3, r3, #23
 648:	61da      	str	r2, [r3, #28]
 * Example of using TIMER_0.
 */
static void TIMER_0_task1_cb(const struct timer_task *const timer_task) // ISR
{
	gpio_toggle_pin_level(LED_onBoard);
}
 64a:	4770      	bx	lr

0000064c <TIMER_0_example>:

void TIMER_0_example(void)
{
 64c:	b510      	push	{r4, lr}
	TIMER_0_task1.interval = 800;
 64e:	4908      	ldr	r1, [pc, #32]	; (670 <TIMER_0_example+0x24>)
 650:	23c8      	movs	r3, #200	; 0xc8
 652:	009b      	lsls	r3, r3, #2
 654:	608b      	str	r3, [r1, #8]
	TIMER_0_task1.cb       = TIMER_0_task1_cb;
 656:	4b07      	ldr	r3, [pc, #28]	; (674 <TIMER_0_example+0x28>)
 658:	60cb      	str	r3, [r1, #12]
	TIMER_0_task1.mode     = TIMER_TASK_REPEAT;
 65a:	2301      	movs	r3, #1
 65c:	740b      	strb	r3, [r1, #16]


	timer_add_task(&TIMER_0, &TIMER_0_task1);
 65e:	4c06      	ldr	r4, [pc, #24]	; (678 <TIMER_0_example+0x2c>)
 660:	0020      	movs	r0, r4
 662:	4b06      	ldr	r3, [pc, #24]	; (67c <TIMER_0_example+0x30>)
 664:	4798      	blx	r3
	timer_start(&TIMER_0);
 666:	0020      	movs	r0, r4
 668:	4b05      	ldr	r3, [pc, #20]	; (680 <TIMER_0_example+0x34>)
 66a:	4798      	blx	r3
}
 66c:	bd10      	pop	{r4, pc}
 66e:	46c0      	nop			; (mov r8, r8)
 670:	20000020 	.word	0x20000020
 674:	00000641 	.word	0x00000641
 678:	20000034 	.word	0x20000034
 67c:	00000361 	.word	0x00000361
 680:	00000325 	.word	0x00000325

00000684 <main>:


int main(void)
{
 684:	b510      	push	{r4, lr}
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
 686:	4b02      	ldr	r3, [pc, #8]	; (690 <main+0xc>)
 688:	4798      	blx	r3
	TIMER_0_example();
 68a:	4b02      	ldr	r3, [pc, #8]	; (694 <main+0x10>)
 68c:	4798      	blx	r3
 68e:	e7fe      	b.n	68e <main+0xa>
 690:	00000105 	.word	0x00000105
 694:	0000064d 	.word	0x0000064d

00000698 <__libc_init_array>:
 698:	b570      	push	{r4, r5, r6, lr}
 69a:	2600      	movs	r6, #0
 69c:	4d0c      	ldr	r5, [pc, #48]	; (6d0 <__libc_init_array+0x38>)
 69e:	4c0d      	ldr	r4, [pc, #52]	; (6d4 <__libc_init_array+0x3c>)
 6a0:	1b64      	subs	r4, r4, r5
 6a2:	10a4      	asrs	r4, r4, #2
 6a4:	42a6      	cmp	r6, r4
 6a6:	d109      	bne.n	6bc <__libc_init_array+0x24>
 6a8:	2600      	movs	r6, #0
 6aa:	f000 f841 	bl	730 <_init>
 6ae:	4d0a      	ldr	r5, [pc, #40]	; (6d8 <__libc_init_array+0x40>)
 6b0:	4c0a      	ldr	r4, [pc, #40]	; (6dc <__libc_init_array+0x44>)
 6b2:	1b64      	subs	r4, r4, r5
 6b4:	10a4      	asrs	r4, r4, #2
 6b6:	42a6      	cmp	r6, r4
 6b8:	d105      	bne.n	6c6 <__libc_init_array+0x2e>
 6ba:	bd70      	pop	{r4, r5, r6, pc}
 6bc:	00b3      	lsls	r3, r6, #2
 6be:	58eb      	ldr	r3, [r5, r3]
 6c0:	4798      	blx	r3
 6c2:	3601      	adds	r6, #1
 6c4:	e7ee      	b.n	6a4 <__libc_init_array+0xc>
 6c6:	00b3      	lsls	r3, r6, #2
 6c8:	58eb      	ldr	r3, [r5, r3]
 6ca:	4798      	blx	r3
 6cc:	3601      	adds	r6, #1
 6ce:	e7f2      	b.n	6b6 <__libc_init_array+0x1e>
 6d0:	0000073c 	.word	0x0000073c
 6d4:	0000073c 	.word	0x0000073c
 6d8:	0000073c 	.word	0x0000073c
 6dc:	00000740 	.word	0x00000740
 6e0:	682f2e2e 	.word	0x682f2e2e
 6e4:	732f6c61 	.word	0x732f6c61
 6e8:	682f6372 	.word	0x682f6372
 6ec:	745f6c61 	.word	0x745f6c61
 6f0:	72656d69 	.word	0x72656d69
 6f4:	0000632e 	.word	0x0000632e
 6f8:	682f2e2e 	.word	0x682f2e2e
 6fc:	752f6c61 	.word	0x752f6c61
 700:	736c6974 	.word	0x736c6974
 704:	6372732f 	.word	0x6372732f
 708:	6974752f 	.word	0x6974752f
 70c:	6c5f736c 	.word	0x6c5f736c
 710:	2e747369 	.word	0x2e747369
 714:	00000063 	.word	0x00000063
 718:	682f2e2e 	.word	0x682f2e2e
 71c:	722f6c70 	.word	0x722f6c70
 720:	682f6374 	.word	0x682f6374
 724:	725f6c70 	.word	0x725f6c70
 728:	632e6374 	.word	0x632e6374
 72c:	00000000 	.word	0x00000000

00000730 <_init>:
 730:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 732:	46c0      	nop			; (mov r8, r8)
 734:	bcf8      	pop	{r3, r4, r5, r6, r7}
 736:	bc08      	pop	{r3}
 738:	469e      	mov	lr, r3
 73a:	4770      	bx	lr

0000073c <__init_array_start>:
 73c:	000000cd 	.word	0x000000cd

00000740 <_fini>:
 740:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 742:	46c0      	nop			; (mov r8, r8)
 744:	bcf8      	pop	{r3, r4, r5, r6, r7}
 746:	bc08      	pop	{r3}
 748:	469e      	mov	lr, r3
 74a:	4770      	bx	lr

0000074c <__fini_array_start>:
 74c:	000000a5 	.word	0x000000a5
